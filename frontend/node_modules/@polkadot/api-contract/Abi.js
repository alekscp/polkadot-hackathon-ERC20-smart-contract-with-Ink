"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _classPrivateFieldLooseBase2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseBase"));

var _classPrivateFieldLooseKey2 = _interopRequireDefault(require("@babel/runtime/helpers/classPrivateFieldLooseKey"));

var _util = require("@polkadot/util");

var _MetaRegistry = _interopRequireDefault(require("./MetaRegistry"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function findMessage(list, messageOrId) {
  const message = (0, _util.isNumber)(messageOrId) ? list[messageOrId] : (0, _util.isString)(messageOrId) ? list.find(({
    identifier
  }) => identifier === messageOrId.toString()) : messageOrId;
  (0, _util.assert)(message, `Attempted to call an invalid contract interface, ${JSON.stringify(messageOrId)}`);
  return message;
}

var _createBase = (0, _classPrivateFieldLooseKey2.default)("createBase");

class Abi {
  constructor(abiJson, chainProperties) {
    this.constructors = void 0;
    this.json = void 0;
    this.messages = void 0;
    this.project = void 0;
    this.registry = void 0;
    Object.defineProperty(this, _createBase, {
      writable: true,
      value: (spec, index, add = {}) => {
        const identifier = spec.name.toString();
        const args = spec.args.map((arg, index) => {
          try {
            (0, _util.assert)((0, _util.isObject)(arg.type), 'Invalid type definition found');
            return {
              name: (0, _util.stringCamelCase)(arg.name.toString()),
              type: this.registry.getMetaTypeDef(arg.type.type)
            };
          } catch (error) {
            console.error(`Error expanding argument ${index} in ${JSON.stringify(spec)}`);
            throw error;
          }
        });
        return _objectSpread(_objectSpread({}, add), {}, {
          args,
          docs: spec.docs.map(doc => doc.toString()),
          identifier,
          index,
          selector: spec.selector
        });
      }
    });
    const json = (0, _util.isString)(abiJson) ? JSON.parse(abiJson) : abiJson;
    (0, _util.assert)((0, _util.isObject)(json) && !Array.isArray(json) && json.metadataVersion && (0, _util.isObject)(json.spec) && !Array.isArray(json.spec) && Array.isArray(json.spec.constructors) && Array.isArray(json.spec.messages), 'Invalid JSON ABI structure supplied, expected a recent metadata version');
    this.json = json;
    this.registry = new _MetaRegistry.default(chainProperties);
    this.project = this.registry.createType('ContractProject', json);
    this.registry.setMetaTypes(this.project.types);
    this.project.types.forEach((_, index) => this.registry.getMetaTypeDef(this.registry.createType('SiLookupTypeId', index + 1)));
    this.constructors = this.project.spec.constructors.map((spec, index) => (0, _classPrivateFieldLooseBase2.default)(this, _createBase)[_createBase](spec, index, {
      isConstructor: true
    }));
    this.messages = this.project.spec.messages.map((spec, index) => {
      const typeSpec = spec.returnType.unwrapOr(null);
      return (0, _classPrivateFieldLooseBase2.default)(this, _createBase)[_createBase](spec, index, {
        isMutating: spec.mutates.isTrue,
        isPayable: spec.payable.isTrue,
        returnType: typeSpec ? this.registry.getMetaTypeDef(typeSpec.type) : null
      });
    });
  }

  findConstructor(constructorOrId) {
    return findMessage(this.constructors, constructorOrId);
  }

  findMessage(messageOrId) {
    return findMessage(this.messages, messageOrId);
  }

}

exports.default = Abi;