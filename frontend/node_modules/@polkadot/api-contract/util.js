"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatData = formatData;
exports.applyOnEvent = applyOnEvent;
exports.encodeMessage = encodeMessage;

var _types = require("@polkadot/types");

var _util = require("@polkadot/util");

// Copyright 2017-2020 @polkadot/rpc-core authors & contributors
// SPDX-License-Identifier: Apache-2.0
function formatData(registry, data, {
  type
}) {
  return (0, _types.createTypeUnsafe)(registry, type, [data], true);
}

function applyOnEvent(result, type, fn) {
  if (result.isInBlock || result.isFinalized) {
    const record = result.findRecord('contracts', type);

    if (record) {
      return fn(record);
    }
  }

  return undefined;
}

function encodeMessage(registry, message, params) {
  (0, _util.assert)(message, 'Attempted to call an invalid contract message');
  (0, _util.assert)(params.length === message.args.length, `Expected ${message.args.length} arguments to contract message '${message.identifier}', found ${params.length}`);
  const Clazz = (0, _types.createClass)(registry, JSON.stringify(message.args.reduce((r, {
    name,
    type
  }) => {
    r[name] = type.displayName || (0, _types.encodeTypeDef)(type);
    return r;
  }, {
    __selector: 'ContractSelector'
  })));
  return (0, _util.compactAddLength)(new Clazz(registry, message.args.reduce((r, {
    name
  }, index) => {
    r[name] = params[index];
    return r;
  }, {
    __selector: message.selector
  })).toU8a());
}