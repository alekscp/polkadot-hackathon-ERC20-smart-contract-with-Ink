{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.paramsNotation = paramsNotation;\nexports.encodeTypeDef = encodeTypeDef;\nexports.withTypeString = withTypeString;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _types = require(\"../../create/types\");\n\nvar _util = require(\"@polkadot/util\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nconst stringIdentity = value => value.toString();\n\nfunction paramsNotation(outer, inner, transform = stringIdentity) {\n  return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(', ')}>` : ''}`;\n} // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\nfunction encodeWithParams(typeDef, outer = typeDef.displayName || typeDef.type) {\n  const {\n    info,\n    params,\n    sub\n  } = typeDef;\n\n  switch (info) {\n    case _types.TypeDefInfo.BTreeMap:\n    case _types.TypeDefInfo.BTreeSet:\n    case _types.TypeDefInfo.Compact:\n    case _types.TypeDefInfo.HashMap:\n    case _types.TypeDefInfo.Linkage:\n    case _types.TypeDefInfo.Option:\n    case _types.TypeDefInfo.Result:\n    case _types.TypeDefInfo.Vec:\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return paramsNotation(outer, params || sub, param => encodeTypeDef(param));\n\n    default:\n      return outer;\n  }\n}\n\nfunction encodeDoNotConstruct({\n  displayName\n}) {\n  return `DoNotEncode<${displayName || 'Unknown'}>`;\n}\n\nfunction encodeSubTypes(sub, asEnum) {\n  const inner = sub.reduce((result, type) => _objectSpread(_objectSpread({}, result), {}, {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [type.name]: encodeTypeDef(type)\n  }), {});\n  return JSON.stringify(asEnum ? {\n    _enum: inner\n  } : inner);\n}\n\nfunction encodeEnum(typeDef) {\n  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Enum type');\n  const sub = typeDef.sub; // c-like enums have all Null entries\n  // TODO We need to take the disciminant into account and auto-add empty entries\n\n  return sub.every(({\n    type\n  }) => type === 'Null') ? `{ _enum: [${sub.map(({\n    name\n  }, index) => `\"${name || `Empty${index}`}\"`).join(', ')}] }` : encodeSubTypes(sub, true);\n}\n\nfunction encodeStruct(typeDef) {\n  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Struct type');\n  return encodeSubTypes(typeDef.sub);\n}\n\nfunction encodeTuple(typeDef) {\n  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Tuple type'); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  return `(${typeDef.sub.map(type => encodeTypeDef(type)).join(', ')})`;\n}\n\nfunction encodeUInt({\n  length\n}, type) {\n  (0, _util.assert)((0, _util.isNumber)(length), 'Unable to encode VecFixed type');\n  return `${type}<${length}>`;\n}\n\nfunction encodeVecFixed({\n  length,\n  sub\n}) {\n  (0, _util.assert)((0, _util.isNumber)(length) && !(0, _util.isUndefined)(sub) && !Array.isArray(sub), 'Unable to encode VecFixed type');\n  return `[${sub.type};${length}]`;\n} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result\n// in a compile-time error with the missing index)\n\n\nconst encoders = {\n  [_types.TypeDefInfo.BTreeMap]: typeDef => encodeWithParams(typeDef, 'BTreeMap'),\n  [_types.TypeDefInfo.BTreeSet]: typeDef => encodeWithParams(typeDef, 'BTreeSet'),\n  [_types.TypeDefInfo.Compact]: typeDef => encodeWithParams(typeDef, 'Compact'),\n  [_types.TypeDefInfo.DoNotConstruct]: typeDef => encodeDoNotConstruct(typeDef),\n  [_types.TypeDefInfo.Enum]: typeDef => encodeEnum(typeDef),\n  [_types.TypeDefInfo.HashMap]: typeDef => encodeWithParams(typeDef, 'HashMap'),\n  [_types.TypeDefInfo.Int]: typeDef => encodeUInt(typeDef, 'Int'),\n  [_types.TypeDefInfo.Linkage]: typeDef => encodeWithParams(typeDef, 'Linkage'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [_types.TypeDefInfo.Null]: typeDef => 'Null',\n  [_types.TypeDefInfo.Option]: typeDef => encodeWithParams(typeDef, 'Option'),\n  [_types.TypeDefInfo.Plain]: typeDef => typeDef.displayName || typeDef.type,\n  [_types.TypeDefInfo.Result]: typeDef => encodeWithParams(typeDef, 'Result'),\n  [_types.TypeDefInfo.Set]: typeDef => typeDef.type,\n  [_types.TypeDefInfo.Struct]: typeDef => encodeStruct(typeDef),\n  [_types.TypeDefInfo.Tuple]: typeDef => encodeTuple(typeDef),\n  [_types.TypeDefInfo.UInt]: typeDef => encodeUInt(typeDef, 'UInt'),\n  [_types.TypeDefInfo.Vec]: typeDef => encodeWithParams(typeDef, 'Vec'),\n  [_types.TypeDefInfo.VecFixed]: typeDef => encodeVecFixed(typeDef)\n};\n\nfunction encodeType(typeDef) {\n  const encoder = encoders[typeDef.info];\n  (0, _util.assert)(encoder, `Cannot encode type: ${JSON.stringify(typeDef)}`);\n  return encoder(typeDef);\n}\n\nfunction encodeTypeDef(typeDef) {\n  (0, _util.assert)(!(0, _util.isUndefined)(typeDef.info), `Invalid type definition with no instance info, ${JSON.stringify(typeDef)}`);\n  return typeDef.displayName || [_types.TypeDefInfo.Enum, _types.TypeDefInfo.Struct].includes(typeDef.info) ? encodeWithParams(typeDef) : encodeType(typeDef);\n}\n\nfunction withTypeString(typeDef) {\n  return _objectSpread(_objectSpread({}, typeDef), {}, {\n    type: encodeType(typeDef)\n  });\n}","map":{"version":3,"sources":["/Users/aclapinpepin/code/substrate-front-end-template/node_modules/@polkadot/api-contract/node_modules/@polkadot/types/codec/utils/encodeTypes.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","paramsNotation","encodeTypeDef","withTypeString","_defineProperty2","_types","_util","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","default","getOwnPropertyDescriptors","defineProperties","stringIdentity","toString","outer","inner","transform","Array","isArray","map","join","encodeWithParams","typeDef","displayName","type","info","params","sub","TypeDefInfo","BTreeMap","BTreeSet","Compact","HashMap","Linkage","Option","Result","Vec","param","encodeDoNotConstruct","encodeSubTypes","asEnum","reduce","result","name","JSON","stringify","_enum","encodeEnum","assert","every","index","encodeStruct","encodeTuple","encodeUInt","isNumber","encodeVecFixed","isUndefined","encoders","DoNotConstruct","Enum","Int","Null","Plain","Set","Struct","Tuple","UInt","VecFixed","encodeType","encoder","includes"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.paramsNotation = paramsNotation;\nexports.encodeTypeDef = encodeTypeDef;\nexports.withTypeString = withTypeString;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _types = require(\"../../create/types\");\n\nvar _util = require(\"@polkadot/util\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nconst stringIdentity = value => value.toString();\n\nfunction paramsNotation(outer, inner, transform = stringIdentity) {\n  return `${outer}${inner ? `<${(Array.isArray(inner) ? inner : [inner]).map(transform).join(', ')}>` : ''}`;\n} // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n\n\nfunction encodeWithParams(typeDef, outer = typeDef.displayName || typeDef.type) {\n  const {\n    info,\n    params,\n    sub\n  } = typeDef;\n\n  switch (info) {\n    case _types.TypeDefInfo.BTreeMap:\n    case _types.TypeDefInfo.BTreeSet:\n    case _types.TypeDefInfo.Compact:\n    case _types.TypeDefInfo.HashMap:\n    case _types.TypeDefInfo.Linkage:\n    case _types.TypeDefInfo.Option:\n    case _types.TypeDefInfo.Result:\n    case _types.TypeDefInfo.Vec:\n      // eslint-disable-next-line @typescript-eslint/no-use-before-define\n      return paramsNotation(outer, params || sub, param => encodeTypeDef(param));\n\n    default:\n      return outer;\n  }\n}\n\nfunction encodeDoNotConstruct({\n  displayName\n}) {\n  return `DoNotEncode<${displayName || 'Unknown'}>`;\n}\n\nfunction encodeSubTypes(sub, asEnum) {\n  const inner = sub.reduce((result, type) => _objectSpread(_objectSpread({}, result), {}, {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    [type.name]: encodeTypeDef(type)\n  }), {});\n  return JSON.stringify(asEnum ? {\n    _enum: inner\n  } : inner);\n}\n\nfunction encodeEnum(typeDef) {\n  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Enum type');\n  const sub = typeDef.sub; // c-like enums have all Null entries\n  // TODO We need to take the disciminant into account and auto-add empty entries\n\n  return sub.every(({\n    type\n  }) => type === 'Null') ? `{ _enum: [${sub.map(({\n    name\n  }, index) => `\"${name || `Empty${index}`}\"`).join(', ')}] }` : encodeSubTypes(sub, true);\n}\n\nfunction encodeStruct(typeDef) {\n  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Struct type');\n  return encodeSubTypes(typeDef.sub);\n}\n\nfunction encodeTuple(typeDef) {\n  (0, _util.assert)(typeDef.sub && Array.isArray(typeDef.sub), 'Unable to encode Tuple type'); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n  return `(${typeDef.sub.map(type => encodeTypeDef(type)).join(', ')})`;\n}\n\nfunction encodeUInt({\n  length\n}, type) {\n  (0, _util.assert)((0, _util.isNumber)(length), 'Unable to encode VecFixed type');\n  return `${type}<${length}>`;\n}\n\nfunction encodeVecFixed({\n  length,\n  sub\n}) {\n  (0, _util.assert)((0, _util.isNumber)(length) && !(0, _util.isUndefined)(sub) && !Array.isArray(sub), 'Unable to encode VecFixed type');\n  return `[${sub.type};${length}]`;\n} // We setup a record here to ensure we have comprehensive coverage (any item not covered will result\n// in a compile-time error with the missing index)\n\n\nconst encoders = {\n  [_types.TypeDefInfo.BTreeMap]: typeDef => encodeWithParams(typeDef, 'BTreeMap'),\n  [_types.TypeDefInfo.BTreeSet]: typeDef => encodeWithParams(typeDef, 'BTreeSet'),\n  [_types.TypeDefInfo.Compact]: typeDef => encodeWithParams(typeDef, 'Compact'),\n  [_types.TypeDefInfo.DoNotConstruct]: typeDef => encodeDoNotConstruct(typeDef),\n  [_types.TypeDefInfo.Enum]: typeDef => encodeEnum(typeDef),\n  [_types.TypeDefInfo.HashMap]: typeDef => encodeWithParams(typeDef, 'HashMap'),\n  [_types.TypeDefInfo.Int]: typeDef => encodeUInt(typeDef, 'Int'),\n  [_types.TypeDefInfo.Linkage]: typeDef => encodeWithParams(typeDef, 'Linkage'),\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  [_types.TypeDefInfo.Null]: typeDef => 'Null',\n  [_types.TypeDefInfo.Option]: typeDef => encodeWithParams(typeDef, 'Option'),\n  [_types.TypeDefInfo.Plain]: typeDef => typeDef.displayName || typeDef.type,\n  [_types.TypeDefInfo.Result]: typeDef => encodeWithParams(typeDef, 'Result'),\n  [_types.TypeDefInfo.Set]: typeDef => typeDef.type,\n  [_types.TypeDefInfo.Struct]: typeDef => encodeStruct(typeDef),\n  [_types.TypeDefInfo.Tuple]: typeDef => encodeTuple(typeDef),\n  [_types.TypeDefInfo.UInt]: typeDef => encodeUInt(typeDef, 'UInt'),\n  [_types.TypeDefInfo.Vec]: typeDef => encodeWithParams(typeDef, 'Vec'),\n  [_types.TypeDefInfo.VecFixed]: typeDef => encodeVecFixed(typeDef)\n};\n\nfunction encodeType(typeDef) {\n  const encoder = encoders[typeDef.info];\n  (0, _util.assert)(encoder, `Cannot encode type: ${JSON.stringify(typeDef)}`);\n  return encoder(typeDef);\n}\n\nfunction encodeTypeDef(typeDef) {\n  (0, _util.assert)(!(0, _util.isUndefined)(typeDef.info), `Invalid type definition with no instance info, ${JSON.stringify(typeDef)}`);\n  return typeDef.displayName || [_types.TypeDefInfo.Enum, _types.TypeDefInfo.Struct].includes(typeDef.info) ? encodeWithParams(typeDef) : encodeType(typeDef);\n}\n\nfunction withTypeString(typeDef) {\n  return _objectSpread(_objectSpread({}, typeDef), {}, {\n    type: encodeType(typeDef)\n  });\n}"]},"metadata":{},"sourceType":"script"}