{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRegistryOffset = getRegistryOffset;\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _types = require(\"@polkadot/types/types\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _types2 = require(\"@polkadot/types\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        (0, _defineProperty2.default)(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n} // convert the offset into project-specific, index-1\n\n\nfunction getRegistryOffset(id) {\n  return id.toNumber() - 1;\n}\n\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n};\n\nvar _siTypes = (0, _classPrivateFieldLooseKey2.default)(\"siTypes\");\n\nvar _getMetaType = (0, _classPrivateFieldLooseKey2.default)(\"getMetaType\");\n\nvar _extract = (0, _classPrivateFieldLooseKey2.default)(\"extract\");\n\nvar _extractArray = (0, _classPrivateFieldLooseKey2.default)(\"extractArray\");\n\nvar _extractFields = (0, _classPrivateFieldLooseKey2.default)(\"extractFields\");\n\nvar _extractPrimitive = (0, _classPrivateFieldLooseKey2.default)(\"extractPrimitive\");\n\nvar _extractPrimitivePath = (0, _classPrivateFieldLooseKey2.default)(\"extractPrimitivePath\");\n\nvar _extractSequence = (0, _classPrivateFieldLooseKey2.default)(\"extractSequence\");\n\nvar _extractTuple = (0, _classPrivateFieldLooseKey2.default)(\"extractTuple\");\n\nvar _extractVariant = (0, _classPrivateFieldLooseKey2.default)(\"extractVariant\");\n\nvar _extractVariantSub = (0, _classPrivateFieldLooseKey2.default)(\"extractVariantSub\");\n\nclass MetaRegistry extends _types2.TypeRegistry {\n  constructor(chainProperties) {\n    super();\n    this.metaTypeDefs = [];\n    Object.defineProperty(this, _siTypes, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _getMetaType, {\n      writable: true,\n      value: id => {\n        const type = (0, _classPrivateFieldLooseBase2.default)(this, _siTypes)[_siTypes][getRegistryOffset(id)];\n\n        (0, _util.assert)(!(0, _util.isUndefined)(type), `getMetaType:: Unable to find ${id.toNumber()} in type values`);\n        return this.createType('SiType', type);\n      }\n    });\n    Object.defineProperty(this, _extract, {\n      writable: true,\n      value: (type, id) => {\n        var _path$pop;\n\n        const path = [...type.path];\n        let typeDef; // TODO solang?\n\n        if (type.path.join('::').startsWith('ink_env::types::')) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractPrimitivePath)[_extractPrimitivePath](type);\n        } else if (type.def.isPrimitive) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractPrimitive)[_extractPrimitive](type);\n        } else if (type.def.isComposite) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractFields)[_extractFields](type.def.asComposite.fields);\n        } else if (type.def.isVariant) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractVariant)[_extractVariant](type.def.asVariant, id);\n        } else if (type.def.isArray) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractArray)[_extractArray](type.def.asArray);\n        } else if (type.def.isSequence) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractSequence)[_extractSequence](type.def.asSequence, id);\n        } else if (type.def.isTuple) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractTuple)[_extractTuple](type.def.asTuple);\n        } else {\n          throw new Error(`Invalid ink! type at index ${id.toString()}`);\n        }\n\n        const displayName = (_path$pop = path.pop()) === null || _path$pop === void 0 ? void 0 : _path$pop.toString();\n        return (0, _types2.withTypeString)(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, displayName ? {\n          displayName\n        } : {}), path.length > 1 ? {\n          namespace: path.map(segment => segment.toString()).join('::')\n        } : {}), type.params.length > 0 ? {\n          params: type.params.map(id => this.getMetaTypeDef(id))\n        } : {}), typeDef));\n      }\n    });\n    Object.defineProperty(this, _extractArray, {\n      writable: true,\n      value: ({\n        len: length,\n        type\n      }) => {\n        (0, _util.assert)(!length || length.toNumber() <= 256, 'MetaRegistry: Only support for [Type; <length>], where length > 256');\n        return {\n          info: _types.TypeDefInfo.VecFixed,\n          length: length.toNumber(),\n          sub: this.getMetaTypeDef(type)\n        };\n      }\n    });\n    Object.defineProperty(this, _extractFields, {\n      writable: true,\n      value: fields => {\n        const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {\n          name\n        }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);\n        let info; // check for tuple first (no fields may be available)\n\n        if (isTuple) {\n          info = _types.TypeDefInfo.Tuple;\n        } else if (isStruct) {\n          info = _types.TypeDefInfo.Struct;\n        } else {\n          throw new Error('Invalid fields type detected, expected either Tuple or Struct');\n        }\n\n        const sub = fields.map(({\n          name,\n          type\n        }) => {\n          return _objectSpread(_objectSpread({}, this.getMetaTypeDef(type)), name.isSome ? {\n            name: name.unwrap().toString()\n          } : {});\n        });\n        return isTuple && sub.length === 1 ? sub[0] : {\n          info,\n          sub\n        };\n      }\n    });\n    Object.defineProperty(this, _extractPrimitive, {\n      writable: true,\n      value: type => {\n        const typeStr = type.def.asPrimitive.type.toString();\n        return {\n          info: _types.TypeDefInfo.Plain,\n          type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n        };\n      }\n    });\n    Object.defineProperty(this, _extractPrimitivePath, {\n      writable: true,\n      value: type => {\n        return {\n          info: _types.TypeDefInfo.Plain,\n          type: type.path[type.path.length - 1].toString()\n        };\n      }\n    });\n    Object.defineProperty(this, _extractSequence, {\n      writable: true,\n      value: ({\n        type\n      }, id) => {\n        (0, _util.assert)(!!type, `ContractRegistry: Invalid sequence type found at id ${id.toString()}`);\n        return {\n          info: _types.TypeDefInfo.Vec,\n          sub: this.getMetaTypeDef(type)\n        };\n      }\n    });\n    Object.defineProperty(this, _extractTuple, {\n      writable: true,\n      value: ids => {\n        return ids.length === 1 ? this.getMetaTypeDef(ids[0]) : {\n          info: _types.TypeDefInfo.Tuple,\n          sub: ids.map(id => this.getMetaTypeDef(id))\n        };\n      }\n    });\n    Object.defineProperty(this, _extractVariant, {\n      writable: true,\n      value: ({\n        variants\n      }, id) => {\n        const {\n          params,\n          path\n        } = (0, _classPrivateFieldLooseBase2.default)(this, _getMetaType)[_getMetaType](id);\n\n        const specialVariant = path[0].toString();\n\n        if (specialVariant === 'Option') {\n          return {\n            info: _types.TypeDefInfo.Option,\n            sub: this.getMetaTypeDef(params[0])\n          };\n        } else if (specialVariant === 'Result') {\n          return {\n            info: _types.TypeDefInfo.Result,\n            sub: params.map((param, index) => _objectSpread({\n              name: ['Ok', 'Error'][index]\n            }, this.getMetaTypeDef(param)))\n          };\n        }\n\n        return {\n          info: _types.TypeDefInfo.Enum,\n          sub: (0, _classPrivateFieldLooseBase2.default)(this, _extractVariantSub)[_extractVariantSub](variants)\n        };\n      }\n    });\n    Object.defineProperty(this, _extractVariantSub, {\n      writable: true,\n      value: variants => {\n        const isAllUnitVariants = variants.every(({\n          fields\n        }) => fields.length === 0);\n\n        if (isAllUnitVariants) {\n          return variants.map(({\n            discriminant,\n            name\n          }) => _objectSpread(_objectSpread({}, discriminant.isSome ? {\n            ext: {\n              discriminant: discriminant.unwrap().toNumber()\n            }\n          } : {}), {}, {\n            info: _types.TypeDefInfo.Plain,\n            name: name.toString(),\n            type: 'Null'\n          }));\n        }\n\n        return variants.map(({\n          fields,\n          name\n        }) => (0, _types2.withTypeString)(_objectSpread(_objectSpread({}, (0, _classPrivateFieldLooseBase2.default)(this, _extractFields)[_extractFields](fields)), {}, {\n          name: name.toString()\n        })));\n      }\n    });\n\n    if (chainProperties) {\n      this.setChainProperties(chainProperties);\n    }\n  }\n\n  setMetaTypes(metaTypes) {\n    (0, _classPrivateFieldLooseBase2.default)(this, _siTypes)[_siTypes] = metaTypes;\n  }\n\n  getMetaTypeDef(id) {\n    const offset = getRegistryOffset(id);\n    let typeDef = this.metaTypeDefs[offset];\n\n    if (!typeDef) {\n      typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extract)[_extract]((0, _classPrivateFieldLooseBase2.default)(this, _getMetaType)[_getMetaType](id), id);\n      this.metaTypeDefs[offset] = typeDef; // Here we protect against the following cases\n      //   - No displayName present, these are generally known primitives\n      //   - displayName === type, these generate circular references\n      //   - displayName Option & type Option<...something...>\n\n      if (typeDef.displayName && !(typeDef.type === typeDef.displayName || typeDef.type.startsWith(`${typeDef.displayName}<`))) {\n        this.register({\n          [typeDef.displayName]: typeDef.type\n        });\n      }\n    }\n\n    return typeDef;\n  }\n\n}\n\nexports.default = MetaRegistry;","map":{"version":3,"sources":["/Users/aclapinpepin/code/substrate-front-end-template/node_modules/@polkadot/api-contract/MetaRegistry.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","getRegistryOffset","default","_defineProperty2","_classPrivateFieldLooseBase2","_classPrivateFieldLooseKey2","_types","_util","_types2","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","id","toNumber","PRIMITIVE_ALIAS","Char","Str","_siTypes","_getMetaType","_extract","_extractArray","_extractFields","_extractPrimitive","_extractPrimitivePath","_extractSequence","_extractTuple","_extractVariant","_extractVariantSub","MetaRegistry","TypeRegistry","constructor","chainProperties","metaTypeDefs","writable","type","assert","isUndefined","createType","_path$pop","path","typeDef","join","startsWith","def","isPrimitive","isComposite","asComposite","fields","isVariant","asVariant","isArray","asArray","isSequence","asSequence","isTuple","asTuple","Error","toString","displayName","pop","withTypeString","namespace","map","segment","params","getMetaTypeDef","len","info","TypeDefInfo","VecFixed","sub","isStruct","reduce","isAllNamed","isAllUnnamed","name","isSome","isNone","Tuple","Struct","unwrap","typeStr","asPrimitive","Plain","toLowerCase","Vec","ids","variants","specialVariant","Option","Result","param","index","Enum","isAllUnitVariants","every","discriminant","ext","setChainProperties","setMetaTypes","metaTypes","offset","register"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getRegistryOffset = getRegistryOffset;\nexports.default = void 0;\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classPrivateFieldLooseBase2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseBase\"));\n\nvar _classPrivateFieldLooseKey2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classPrivateFieldLooseKey\"));\n\nvar _types = require(\"@polkadot/types/types\");\n\nvar _util = require(\"@polkadot/util\");\n\nvar _types2 = require(\"@polkadot/types\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n// convert the offset into project-specific, index-1\nfunction getRegistryOffset(id) {\n  return id.toNumber() - 1;\n}\n\nconst PRIMITIVE_ALIAS = {\n  Char: 'u32',\n  // Rust char is 4-bytes\n  Str: 'Text'\n};\n\nvar _siTypes = (0, _classPrivateFieldLooseKey2.default)(\"siTypes\");\n\nvar _getMetaType = (0, _classPrivateFieldLooseKey2.default)(\"getMetaType\");\n\nvar _extract = (0, _classPrivateFieldLooseKey2.default)(\"extract\");\n\nvar _extractArray = (0, _classPrivateFieldLooseKey2.default)(\"extractArray\");\n\nvar _extractFields = (0, _classPrivateFieldLooseKey2.default)(\"extractFields\");\n\nvar _extractPrimitive = (0, _classPrivateFieldLooseKey2.default)(\"extractPrimitive\");\n\nvar _extractPrimitivePath = (0, _classPrivateFieldLooseKey2.default)(\"extractPrimitivePath\");\n\nvar _extractSequence = (0, _classPrivateFieldLooseKey2.default)(\"extractSequence\");\n\nvar _extractTuple = (0, _classPrivateFieldLooseKey2.default)(\"extractTuple\");\n\nvar _extractVariant = (0, _classPrivateFieldLooseKey2.default)(\"extractVariant\");\n\nvar _extractVariantSub = (0, _classPrivateFieldLooseKey2.default)(\"extractVariantSub\");\n\nclass MetaRegistry extends _types2.TypeRegistry {\n  constructor(chainProperties) {\n    super();\n    this.metaTypeDefs = [];\n    Object.defineProperty(this, _siTypes, {\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, _getMetaType, {\n      writable: true,\n      value: id => {\n        const type = (0, _classPrivateFieldLooseBase2.default)(this, _siTypes)[_siTypes][getRegistryOffset(id)];\n\n        (0, _util.assert)(!(0, _util.isUndefined)(type), `getMetaType:: Unable to find ${id.toNumber()} in type values`);\n        return this.createType('SiType', type);\n      }\n    });\n    Object.defineProperty(this, _extract, {\n      writable: true,\n      value: (type, id) => {\n        var _path$pop;\n\n        const path = [...type.path];\n        let typeDef; // TODO solang?\n\n        if (type.path.join('::').startsWith('ink_env::types::')) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractPrimitivePath)[_extractPrimitivePath](type);\n        } else if (type.def.isPrimitive) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractPrimitive)[_extractPrimitive](type);\n        } else if (type.def.isComposite) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractFields)[_extractFields](type.def.asComposite.fields);\n        } else if (type.def.isVariant) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractVariant)[_extractVariant](type.def.asVariant, id);\n        } else if (type.def.isArray) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractArray)[_extractArray](type.def.asArray);\n        } else if (type.def.isSequence) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractSequence)[_extractSequence](type.def.asSequence, id);\n        } else if (type.def.isTuple) {\n          typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extractTuple)[_extractTuple](type.def.asTuple);\n        } else {\n          throw new Error(`Invalid ink! type at index ${id.toString()}`);\n        }\n\n        const displayName = (_path$pop = path.pop()) === null || _path$pop === void 0 ? void 0 : _path$pop.toString();\n        return (0, _types2.withTypeString)(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, displayName ? {\n          displayName\n        } : {}), path.length > 1 ? {\n          namespace: path.map(segment => segment.toString()).join('::')\n        } : {}), type.params.length > 0 ? {\n          params: type.params.map(id => this.getMetaTypeDef(id))\n        } : {}), typeDef));\n      }\n    });\n    Object.defineProperty(this, _extractArray, {\n      writable: true,\n      value: ({\n        len: length,\n        type\n      }) => {\n        (0, _util.assert)(!length || length.toNumber() <= 256, 'MetaRegistry: Only support for [Type; <length>], where length > 256');\n        return {\n          info: _types.TypeDefInfo.VecFixed,\n          length: length.toNumber(),\n          sub: this.getMetaTypeDef(type)\n        };\n      }\n    });\n    Object.defineProperty(this, _extractFields, {\n      writable: true,\n      value: fields => {\n        const [isStruct, isTuple] = fields.reduce(([isAllNamed, isAllUnnamed], {\n          name\n        }) => [isAllNamed && name.isSome, isAllUnnamed && name.isNone], [true, true]);\n        let info; // check for tuple first (no fields may be available)\n\n        if (isTuple) {\n          info = _types.TypeDefInfo.Tuple;\n        } else if (isStruct) {\n          info = _types.TypeDefInfo.Struct;\n        } else {\n          throw new Error('Invalid fields type detected, expected either Tuple or Struct');\n        }\n\n        const sub = fields.map(({\n          name,\n          type\n        }) => {\n          return _objectSpread(_objectSpread({}, this.getMetaTypeDef(type)), name.isSome ? {\n            name: name.unwrap().toString()\n          } : {});\n        });\n        return isTuple && sub.length === 1 ? sub[0] : {\n          info,\n          sub\n        };\n      }\n    });\n    Object.defineProperty(this, _extractPrimitive, {\n      writable: true,\n      value: type => {\n        const typeStr = type.def.asPrimitive.type.toString();\n        return {\n          info: _types.TypeDefInfo.Plain,\n          type: PRIMITIVE_ALIAS[typeStr] || typeStr.toLowerCase()\n        };\n      }\n    });\n    Object.defineProperty(this, _extractPrimitivePath, {\n      writable: true,\n      value: type => {\n        return {\n          info: _types.TypeDefInfo.Plain,\n          type: type.path[type.path.length - 1].toString()\n        };\n      }\n    });\n    Object.defineProperty(this, _extractSequence, {\n      writable: true,\n      value: ({\n        type\n      }, id) => {\n        (0, _util.assert)(!!type, `ContractRegistry: Invalid sequence type found at id ${id.toString()}`);\n        return {\n          info: _types.TypeDefInfo.Vec,\n          sub: this.getMetaTypeDef(type)\n        };\n      }\n    });\n    Object.defineProperty(this, _extractTuple, {\n      writable: true,\n      value: ids => {\n        return ids.length === 1 ? this.getMetaTypeDef(ids[0]) : {\n          info: _types.TypeDefInfo.Tuple,\n          sub: ids.map(id => this.getMetaTypeDef(id))\n        };\n      }\n    });\n    Object.defineProperty(this, _extractVariant, {\n      writable: true,\n      value: ({\n        variants\n      }, id) => {\n        const {\n          params,\n          path\n        } = (0, _classPrivateFieldLooseBase2.default)(this, _getMetaType)[_getMetaType](id);\n\n        const specialVariant = path[0].toString();\n\n        if (specialVariant === 'Option') {\n          return {\n            info: _types.TypeDefInfo.Option,\n            sub: this.getMetaTypeDef(params[0])\n          };\n        } else if (specialVariant === 'Result') {\n          return {\n            info: _types.TypeDefInfo.Result,\n            sub: params.map((param, index) => _objectSpread({\n              name: ['Ok', 'Error'][index]\n            }, this.getMetaTypeDef(param)))\n          };\n        }\n\n        return {\n          info: _types.TypeDefInfo.Enum,\n          sub: (0, _classPrivateFieldLooseBase2.default)(this, _extractVariantSub)[_extractVariantSub](variants)\n        };\n      }\n    });\n    Object.defineProperty(this, _extractVariantSub, {\n      writable: true,\n      value: variants => {\n        const isAllUnitVariants = variants.every(({\n          fields\n        }) => fields.length === 0);\n\n        if (isAllUnitVariants) {\n          return variants.map(({\n            discriminant,\n            name\n          }) => _objectSpread(_objectSpread({}, discriminant.isSome ? {\n            ext: {\n              discriminant: discriminant.unwrap().toNumber()\n            }\n          } : {}), {}, {\n            info: _types.TypeDefInfo.Plain,\n            name: name.toString(),\n            type: 'Null'\n          }));\n        }\n\n        return variants.map(({\n          fields,\n          name\n        }) => (0, _types2.withTypeString)(_objectSpread(_objectSpread({}, (0, _classPrivateFieldLooseBase2.default)(this, _extractFields)[_extractFields](fields)), {}, {\n          name: name.toString()\n        })));\n      }\n    });\n\n    if (chainProperties) {\n      this.setChainProperties(chainProperties);\n    }\n  }\n\n  setMetaTypes(metaTypes) {\n    (0, _classPrivateFieldLooseBase2.default)(this, _siTypes)[_siTypes] = metaTypes;\n  }\n\n  getMetaTypeDef(id) {\n    const offset = getRegistryOffset(id);\n    let typeDef = this.metaTypeDefs[offset];\n\n    if (!typeDef) {\n      typeDef = (0, _classPrivateFieldLooseBase2.default)(this, _extract)[_extract]((0, _classPrivateFieldLooseBase2.default)(this, _getMetaType)[_getMetaType](id), id);\n      this.metaTypeDefs[offset] = typeDef; // Here we protect against the following cases\n      //   - No displayName present, these are generally known primitives\n      //   - displayName === type, these generate circular references\n      //   - displayName Option & type Option<...something...>\n\n      if (typeDef.displayName && !(typeDef.type === typeDef.displayName || typeDef.type.startsWith(`${typeDef.displayName}<`))) {\n        this.register({\n          [typeDef.displayName]: typeDef.type\n        });\n      }\n    }\n\n    return typeDef;\n  }\n\n}\n\nexports.default = MetaRegistry;"]},"metadata":{},"sourceType":"script"}