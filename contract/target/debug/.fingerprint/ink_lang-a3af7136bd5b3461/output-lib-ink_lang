{"message":"function pointers cannot appear in constant functions","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using rustup).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":5136,"byte_end":5148,"line_start":186,"line_end":186,"column_start":30,"column_end":42,"is_primary":true,"text":[{"text":"            pub const fn new(dispatchable: $dispatchable_fn<Msg, S>) -> Self {","highlight_start":30,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":6875,"byte_end":6990,"line_start":237,"line_end":240,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_dispatcher_for! {","highlight_start":1,"highlight_end":23},{"text":"    /// Dispatcher for storage preserving messages.","highlight_start":1,"highlight_end":52},{"text":"    struct Dispatcher(DispatchableFn);","highlight_start":1,"highlight_end":39},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_dispatcher_for!","def_site_span":{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":3701,"byte_end":6873,"line_start":133,"line_end":235,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_dispatcher_for {","highlight_start":1,"highlight_end":35},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $( #[$meta:meta] )*","highlight_start":1,"highlight_end":28},{"text":"        struct $name:ident( $dispatchable_fn:ident ); $($tt:tt)?","highlight_start":1,"highlight_end":65},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        $( #[$meta] )*","highlight_start":1,"highlight_end":23},{"text":"        pub struct $name<Msg, S>","highlight_start":1,"highlight_end":33},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// The dispatchable function.","highlight_start":1,"highlight_end":43},{"text":"            dispatchable: $dispatchable_fn<Msg, S>,","highlight_start":1,"highlight_end":52},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> FnSelector for $name<Msg, S>","highlight_start":1,"highlight_end":50},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput + FnSelector,","highlight_start":1,"highlight_end":50},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            const SELECTOR: Selector = <Msg as FnSelector>::SELECTOR;","highlight_start":1,"highlight_end":70},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Copy for $name<Msg, S>","highlight_start":1,"highlight_end":44},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Clone for $name<Msg, S>","highlight_start":1,"highlight_end":45},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            fn clone(&self) -> Self {","highlight_start":1,"highlight_end":38},{"text":"                Self {","highlight_start":1,"highlight_end":23},{"text":"                    dispatchable: self.dispatchable,","highlight_start":1,"highlight_end":53},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> $name<Msg, S>","highlight_start":1,"highlight_end":35},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput + FnSelector,","highlight_start":1,"highlight_end":50},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// Returns the associated handler selector.","highlight_start":1,"highlight_end":57},{"text":"            pub const fn selector() -> Selector {","highlight_start":1,"highlight_end":50},{"text":"                <Msg as FnSelector>::SELECTOR","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> $name<Msg, S>","highlight_start":1,"highlight_end":35},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// Constructs a message handler from its raw counterpart.","highlight_start":1,"highlight_end":71},{"text":"            pub const fn new(dispatchable: $dispatchable_fn<Msg, S>) -> Self {","highlight_start":1,"highlight_end":79},{"text":"                Self { dispatchable }","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Calls the dispatchable function and returns its result.","highlight_start":1,"highlight_end":72},{"text":"            pub fn eval(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                storage: & $($tt)* S,","highlight_start":1,"highlight_end":38},{"text":"                inputs: <Msg as FnInput>::Input,","highlight_start":1,"highlight_end":49},{"text":"            ) -> <Msg as FnOutput>::Output {","highlight_start":1,"highlight_end":45},{"text":"                (self.dispatchable)(storage, inputs)","highlight_start":1,"highlight_end":53},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Dispatch<S> for $name<Msg, S>","highlight_start":1,"highlight_end":51},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: Message,","highlight_start":1,"highlight_end":26},{"text":"            <Msg as FnInput>::Input: scale::Decode,","highlight_start":1,"highlight_end":52},{"text":"            <Msg as FnOutput>::Output: scale::Encode,","highlight_start":1,"highlight_end":54},{"text":"            S: Flush,","highlight_start":1,"highlight_end":22},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            fn dispatch<T>(&self, storage: &mut S, data: &CallData) -> Result<()>","highlight_start":1,"highlight_end":82},{"text":"            where","highlight_start":1,"highlight_end":18},{"text":"                T: EnvTypes,","highlight_start":1,"highlight_end":29},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                use scale::Decode as _;","highlight_start":1,"highlight_end":40},{"text":"                let args = <Msg as FnInput>::Input::decode(&mut &data.params()[..])","highlight_start":1,"highlight_end":84},{"text":"                    .map_err(|_| DispatchError::InvalidParameters)?;","highlight_start":1,"highlight_end":69},{"text":"                let result = self.eval(storage, args);","highlight_start":1,"highlight_end":55},{"text":"                if TypeId::of::<<Msg as FnOutput>::Output>() != TypeId::of::<()>() {","highlight_start":1,"highlight_end":85},{"text":"                    ink_core::env::output::<<Msg as FnOutput>::Output>(&result)","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if <Msg as Message>::IS_MUT {","highlight_start":1,"highlight_end":46},{"text":"                    // Flush the storage since the message might have mutated it.","highlight_start":1,"highlight_end":82},{"text":"                    Flush::flush(storage);","highlight_start":1,"highlight_end":43},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ( // Forwarding rule for `mut`","highlight_start":1,"highlight_end":35},{"text":"        $( #[$meta:meta] )*","highlight_start":1,"highlight_end":28},{"text":"        struct $name:ident( mut $dispatchable_fn:ident );","highlight_start":1,"highlight_end":58},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        impl_dispatcher_for! {","highlight_start":1,"highlight_end":31},{"text":"            $( #[$meta] )*","highlight_start":1,"highlight_end":27},{"text":"            struct $name( $dispatchable_fn ); mut","highlight_start":1,"highlight_end":50},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(const_fn_fn_ptr_basics)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: function pointers cannot appear in constant functions\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs:186:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m            pub const fn new(dispatchable: $dispatchable_fn<Msg, S>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m237\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_dispatcher_for! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m238\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Dispatcher for storage preserving messages.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m239\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    struct Dispatcher(DispatchableFn);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m240\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(const_fn_fn_ptr_basics)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"function pointers cannot appear in constant functions","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using rustup).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":5136,"byte_end":5148,"line_start":186,"line_end":186,"column_start":30,"column_end":42,"is_primary":true,"text":[{"text":"            pub const fn new(dispatchable: $dispatchable_fn<Msg, S>) -> Self {","highlight_start":30,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":6755,"byte_end":6864,"line_start":230,"line_end":233,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        impl_dispatcher_for! {","highlight_start":9,"highlight_end":31},{"text":"            $( #[$meta] )*","highlight_start":1,"highlight_end":27},{"text":"            struct $name( $dispatchable_fn ); mut","highlight_start":1,"highlight_end":50},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":6992,"byte_end":7144,"line_start":242,"line_end":245,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_dispatcher_for! {","highlight_start":1,"highlight_end":23},{"text":"    /// Dispatcher for potentially storage mutating messages and constructors.","highlight_start":1,"highlight_end":79},{"text":"    struct DispatcherMut(mut DispatchableFnMut);","highlight_start":1,"highlight_end":49},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_dispatcher_for!","def_site_span":{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":3701,"byte_end":6873,"line_start":133,"line_end":235,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_dispatcher_for {","highlight_start":1,"highlight_end":35},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $( #[$meta:meta] )*","highlight_start":1,"highlight_end":28},{"text":"        struct $name:ident( $dispatchable_fn:ident ); $($tt:tt)?","highlight_start":1,"highlight_end":65},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        $( #[$meta] )*","highlight_start":1,"highlight_end":23},{"text":"        pub struct $name<Msg, S>","highlight_start":1,"highlight_end":33},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// The dispatchable function.","highlight_start":1,"highlight_end":43},{"text":"            dispatchable: $dispatchable_fn<Msg, S>,","highlight_start":1,"highlight_end":52},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> FnSelector for $name<Msg, S>","highlight_start":1,"highlight_end":50},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput + FnSelector,","highlight_start":1,"highlight_end":50},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            const SELECTOR: Selector = <Msg as FnSelector>::SELECTOR;","highlight_start":1,"highlight_end":70},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Copy for $name<Msg, S>","highlight_start":1,"highlight_end":44},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Clone for $name<Msg, S>","highlight_start":1,"highlight_end":45},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            fn clone(&self) -> Self {","highlight_start":1,"highlight_end":38},{"text":"                Self {","highlight_start":1,"highlight_end":23},{"text":"                    dispatchable: self.dispatchable,","highlight_start":1,"highlight_end":53},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> $name<Msg, S>","highlight_start":1,"highlight_end":35},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput + FnSelector,","highlight_start":1,"highlight_end":50},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// Returns the associated handler selector.","highlight_start":1,"highlight_end":57},{"text":"            pub const fn selector() -> Selector {","highlight_start":1,"highlight_end":50},{"text":"                <Msg as FnSelector>::SELECTOR","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> $name<Msg, S>","highlight_start":1,"highlight_end":35},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// Constructs a message handler from its raw counterpart.","highlight_start":1,"highlight_end":71},{"text":"            pub const fn new(dispatchable: $dispatchable_fn<Msg, S>) -> Self {","highlight_start":1,"highlight_end":79},{"text":"                Self { dispatchable }","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Calls the dispatchable function and returns its result.","highlight_start":1,"highlight_end":72},{"text":"            pub fn eval(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                storage: & $($tt)* S,","highlight_start":1,"highlight_end":38},{"text":"                inputs: <Msg as FnInput>::Input,","highlight_start":1,"highlight_end":49},{"text":"            ) -> <Msg as FnOutput>::Output {","highlight_start":1,"highlight_end":45},{"text":"                (self.dispatchable)(storage, inputs)","highlight_start":1,"highlight_end":53},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Dispatch<S> for $name<Msg, S>","highlight_start":1,"highlight_end":51},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: Message,","highlight_start":1,"highlight_end":26},{"text":"            <Msg as FnInput>::Input: scale::Decode,","highlight_start":1,"highlight_end":52},{"text":"            <Msg as FnOutput>::Output: scale::Encode,","highlight_start":1,"highlight_end":54},{"text":"            S: Flush,","highlight_start":1,"highlight_end":22},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            fn dispatch<T>(&self, storage: &mut S, data: &CallData) -> Result<()>","highlight_start":1,"highlight_end":82},{"text":"            where","highlight_start":1,"highlight_end":18},{"text":"                T: EnvTypes,","highlight_start":1,"highlight_end":29},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                use scale::Decode as _;","highlight_start":1,"highlight_end":40},{"text":"                let args = <Msg as FnInput>::Input::decode(&mut &data.params()[..])","highlight_start":1,"highlight_end":84},{"text":"                    .map_err(|_| DispatchError::InvalidParameters)?;","highlight_start":1,"highlight_end":69},{"text":"                let result = self.eval(storage, args);","highlight_start":1,"highlight_end":55},{"text":"                if TypeId::of::<<Msg as FnOutput>::Output>() != TypeId::of::<()>() {","highlight_start":1,"highlight_end":85},{"text":"                    ink_core::env::output::<<Msg as FnOutput>::Output>(&result)","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if <Msg as Message>::IS_MUT {","highlight_start":1,"highlight_end":46},{"text":"                    // Flush the storage since the message might have mutated it.","highlight_start":1,"highlight_end":82},{"text":"                    Flush::flush(storage);","highlight_start":1,"highlight_end":43},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ( // Forwarding rule for `mut`","highlight_start":1,"highlight_end":35},{"text":"        $( #[$meta:meta] )*","highlight_start":1,"highlight_end":28},{"text":"        struct $name:ident( mut $dispatchable_fn:ident );","highlight_start":1,"highlight_end":58},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        impl_dispatcher_for! {","highlight_start":1,"highlight_end":31},{"text":"            $( #[$meta] )*","highlight_start":1,"highlight_end":27},{"text":"            struct $name( $dispatchable_fn ); mut","highlight_start":1,"highlight_end":50},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"impl_dispatcher_for!","def_site_span":{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":3701,"byte_end":6873,"line_start":133,"line_end":235,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_dispatcher_for {","highlight_start":1,"highlight_end":35},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $( #[$meta:meta] )*","highlight_start":1,"highlight_end":28},{"text":"        struct $name:ident( $dispatchable_fn:ident ); $($tt:tt)?","highlight_start":1,"highlight_end":65},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        $( #[$meta] )*","highlight_start":1,"highlight_end":23},{"text":"        pub struct $name<Msg, S>","highlight_start":1,"highlight_end":33},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// The dispatchable function.","highlight_start":1,"highlight_end":43},{"text":"            dispatchable: $dispatchable_fn<Msg, S>,","highlight_start":1,"highlight_end":52},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> FnSelector for $name<Msg, S>","highlight_start":1,"highlight_end":50},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput + FnSelector,","highlight_start":1,"highlight_end":50},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            const SELECTOR: Selector = <Msg as FnSelector>::SELECTOR;","highlight_start":1,"highlight_end":70},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Copy for $name<Msg, S>","highlight_start":1,"highlight_end":44},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Clone for $name<Msg, S>","highlight_start":1,"highlight_end":45},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            fn clone(&self) -> Self {","highlight_start":1,"highlight_end":38},{"text":"                Self {","highlight_start":1,"highlight_end":23},{"text":"                    dispatchable: self.dispatchable,","highlight_start":1,"highlight_end":53},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> $name<Msg, S>","highlight_start":1,"highlight_end":35},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput + FnSelector,","highlight_start":1,"highlight_end":50},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// Returns the associated handler selector.","highlight_start":1,"highlight_end":57},{"text":"            pub const fn selector() -> Selector {","highlight_start":1,"highlight_end":50},{"text":"                <Msg as FnSelector>::SELECTOR","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> $name<Msg, S>","highlight_start":1,"highlight_end":35},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// Constructs a message handler from its raw counterpart.","highlight_start":1,"highlight_end":71},{"text":"            pub const fn new(dispatchable: $dispatchable_fn<Msg, S>) -> Self {","highlight_start":1,"highlight_end":79},{"text":"                Self { dispatchable }","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Calls the dispatchable function and returns its result.","highlight_start":1,"highlight_end":72},{"text":"            pub fn eval(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                storage: & $($tt)* S,","highlight_start":1,"highlight_end":38},{"text":"                inputs: <Msg as FnInput>::Input,","highlight_start":1,"highlight_end":49},{"text":"            ) -> <Msg as FnOutput>::Output {","highlight_start":1,"highlight_end":45},{"text":"                (self.dispatchable)(storage, inputs)","highlight_start":1,"highlight_end":53},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Dispatch<S> for $name<Msg, S>","highlight_start":1,"highlight_end":51},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: Message,","highlight_start":1,"highlight_end":26},{"text":"            <Msg as FnInput>::Input: scale::Decode,","highlight_start":1,"highlight_end":52},{"text":"            <Msg as FnOutput>::Output: scale::Encode,","highlight_start":1,"highlight_end":54},{"text":"            S: Flush,","highlight_start":1,"highlight_end":22},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            fn dispatch<T>(&self, storage: &mut S, data: &CallData) -> Result<()>","highlight_start":1,"highlight_end":82},{"text":"            where","highlight_start":1,"highlight_end":18},{"text":"                T: EnvTypes,","highlight_start":1,"highlight_end":29},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                use scale::Decode as _;","highlight_start":1,"highlight_end":40},{"text":"                let args = <Msg as FnInput>::Input::decode(&mut &data.params()[..])","highlight_start":1,"highlight_end":84},{"text":"                    .map_err(|_| DispatchError::InvalidParameters)?;","highlight_start":1,"highlight_end":69},{"text":"                let result = self.eval(storage, args);","highlight_start":1,"highlight_end":55},{"text":"                if TypeId::of::<<Msg as FnOutput>::Output>() != TypeId::of::<()>() {","highlight_start":1,"highlight_end":85},{"text":"                    ink_core::env::output::<<Msg as FnOutput>::Output>(&result)","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if <Msg as Message>::IS_MUT {","highlight_start":1,"highlight_end":46},{"text":"                    // Flush the storage since the message might have mutated it.","highlight_start":1,"highlight_end":82},{"text":"                    Flush::flush(storage);","highlight_start":1,"highlight_end":43},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ( // Forwarding rule for `mut`","highlight_start":1,"highlight_end":35},{"text":"        $( #[$meta:meta] )*","highlight_start":1,"highlight_end":28},{"text":"        struct $name:ident( mut $dispatchable_fn:ident );","highlight_start":1,"highlight_end":58},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        impl_dispatcher_for! {","highlight_start":1,"highlight_end":31},{"text":"            $( #[$meta] )*","highlight_start":1,"highlight_end":27},{"text":"            struct $name( $dispatchable_fn ); mut","highlight_start":1,"highlight_end":50},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(const_fn_fn_ptr_basics)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: function pointers cannot appear in constant functions\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs:186:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m            pub const fn new(dispatchable: $dispatchable_fn<Msg, S>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m242\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_dispatcher_for! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m243\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Dispatcher for potentially storage mutating messages and constructors.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m244\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    struct DispatcherMut(mut DispatchableFnMut);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m245\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #57563 <https://github.com/rust-lang/rust/issues/57563> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(const_fn_fn_ptr_basics)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"mutable references are not allowed in constant functions","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n```compile_fail,E0658\n#[repr(u128)] // error: use of unstable library feature 'repr128'\nenum Foo {\n    Bar(u64),\n}\n```\n\nIf you're using a stable or a beta version of rustc, you won't be able to use\nany unstable features. In order to do so, please switch to a nightly version of\nrustc (by using rustup).\n\nIf you're using a nightly version of rustc, just add the corresponding feature\nto be able to use it:\n\n```\n#![feature(repr128)]\n\n#[repr(u128)] // ok!\nenum Foo {\n    Bar(u64),\n}\n```\n"},"level":"error","spans":[{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":5136,"byte_end":5148,"line_start":186,"line_end":186,"column_start":30,"column_end":42,"is_primary":true,"text":[{"text":"            pub const fn new(dispatchable: $dispatchable_fn<Msg, S>) -> Self {","highlight_start":30,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":6755,"byte_end":6864,"line_start":230,"line_end":233,"column_start":9,"column_end":10,"is_primary":false,"text":[{"text":"        impl_dispatcher_for! {","highlight_start":9,"highlight_end":31},{"text":"            $( #[$meta] )*","highlight_start":1,"highlight_end":27},{"text":"            struct $name( $dispatchable_fn ); mut","highlight_start":1,"highlight_end":50},{"text":"        }","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":6992,"byte_end":7144,"line_start":242,"line_end":245,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"impl_dispatcher_for! {","highlight_start":1,"highlight_end":23},{"text":"    /// Dispatcher for potentially storage mutating messages and constructors.","highlight_start":1,"highlight_end":79},{"text":"    struct DispatcherMut(mut DispatchableFnMut);","highlight_start":1,"highlight_end":49},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"impl_dispatcher_for!","def_site_span":{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":3701,"byte_end":6873,"line_start":133,"line_end":235,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_dispatcher_for {","highlight_start":1,"highlight_end":35},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $( #[$meta:meta] )*","highlight_start":1,"highlight_end":28},{"text":"        struct $name:ident( $dispatchable_fn:ident ); $($tt:tt)?","highlight_start":1,"highlight_end":65},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        $( #[$meta] )*","highlight_start":1,"highlight_end":23},{"text":"        pub struct $name<Msg, S>","highlight_start":1,"highlight_end":33},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// The dispatchable function.","highlight_start":1,"highlight_end":43},{"text":"            dispatchable: $dispatchable_fn<Msg, S>,","highlight_start":1,"highlight_end":52},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> FnSelector for $name<Msg, S>","highlight_start":1,"highlight_end":50},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput + FnSelector,","highlight_start":1,"highlight_end":50},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            const SELECTOR: Selector = <Msg as FnSelector>::SELECTOR;","highlight_start":1,"highlight_end":70},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Copy for $name<Msg, S>","highlight_start":1,"highlight_end":44},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Clone for $name<Msg, S>","highlight_start":1,"highlight_end":45},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            fn clone(&self) -> Self {","highlight_start":1,"highlight_end":38},{"text":"                Self {","highlight_start":1,"highlight_end":23},{"text":"                    dispatchable: self.dispatchable,","highlight_start":1,"highlight_end":53},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> $name<Msg, S>","highlight_start":1,"highlight_end":35},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput + FnSelector,","highlight_start":1,"highlight_end":50},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// Returns the associated handler selector.","highlight_start":1,"highlight_end":57},{"text":"            pub const fn selector() -> Selector {","highlight_start":1,"highlight_end":50},{"text":"                <Msg as FnSelector>::SELECTOR","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> $name<Msg, S>","highlight_start":1,"highlight_end":35},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// Constructs a message handler from its raw counterpart.","highlight_start":1,"highlight_end":71},{"text":"            pub const fn new(dispatchable: $dispatchable_fn<Msg, S>) -> Self {","highlight_start":1,"highlight_end":79},{"text":"                Self { dispatchable }","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Calls the dispatchable function and returns its result.","highlight_start":1,"highlight_end":72},{"text":"            pub fn eval(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                storage: & $($tt)* S,","highlight_start":1,"highlight_end":38},{"text":"                inputs: <Msg as FnInput>::Input,","highlight_start":1,"highlight_end":49},{"text":"            ) -> <Msg as FnOutput>::Output {","highlight_start":1,"highlight_end":45},{"text":"                (self.dispatchable)(storage, inputs)","highlight_start":1,"highlight_end":53},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Dispatch<S> for $name<Msg, S>","highlight_start":1,"highlight_end":51},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: Message,","highlight_start":1,"highlight_end":26},{"text":"            <Msg as FnInput>::Input: scale::Decode,","highlight_start":1,"highlight_end":52},{"text":"            <Msg as FnOutput>::Output: scale::Encode,","highlight_start":1,"highlight_end":54},{"text":"            S: Flush,","highlight_start":1,"highlight_end":22},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            fn dispatch<T>(&self, storage: &mut S, data: &CallData) -> Result<()>","highlight_start":1,"highlight_end":82},{"text":"            where","highlight_start":1,"highlight_end":18},{"text":"                T: EnvTypes,","highlight_start":1,"highlight_end":29},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                use scale::Decode as _;","highlight_start":1,"highlight_end":40},{"text":"                let args = <Msg as FnInput>::Input::decode(&mut &data.params()[..])","highlight_start":1,"highlight_end":84},{"text":"                    .map_err(|_| DispatchError::InvalidParameters)?;","highlight_start":1,"highlight_end":69},{"text":"                let result = self.eval(storage, args);","highlight_start":1,"highlight_end":55},{"text":"                if TypeId::of::<<Msg as FnOutput>::Output>() != TypeId::of::<()>() {","highlight_start":1,"highlight_end":85},{"text":"                    ink_core::env::output::<<Msg as FnOutput>::Output>(&result)","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if <Msg as Message>::IS_MUT {","highlight_start":1,"highlight_end":46},{"text":"                    // Flush the storage since the message might have mutated it.","highlight_start":1,"highlight_end":82},{"text":"                    Flush::flush(storage);","highlight_start":1,"highlight_end":43},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ( // Forwarding rule for `mut`","highlight_start":1,"highlight_end":35},{"text":"        $( #[$meta:meta] )*","highlight_start":1,"highlight_end":28},{"text":"        struct $name:ident( mut $dispatchable_fn:ident );","highlight_start":1,"highlight_end":58},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        impl_dispatcher_for! {","highlight_start":1,"highlight_end":31},{"text":"            $( #[$meta] )*","highlight_start":1,"highlight_end":27},{"text":"            struct $name( $dispatchable_fn ); mut","highlight_start":1,"highlight_end":50},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"impl_dispatcher_for!","def_site_span":{"file_name":"/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs","byte_start":3701,"byte_end":6873,"line_start":133,"line_end":235,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"macro_rules! impl_dispatcher_for {","highlight_start":1,"highlight_end":35},{"text":"    (","highlight_start":1,"highlight_end":6},{"text":"        $( #[$meta:meta] )*","highlight_start":1,"highlight_end":28},{"text":"        struct $name:ident( $dispatchable_fn:ident ); $($tt:tt)?","highlight_start":1,"highlight_end":65},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        $( #[$meta] )*","highlight_start":1,"highlight_end":23},{"text":"        pub struct $name<Msg, S>","highlight_start":1,"highlight_end":33},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// The dispatchable function.","highlight_start":1,"highlight_end":43},{"text":"            dispatchable: $dispatchable_fn<Msg, S>,","highlight_start":1,"highlight_end":52},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> FnSelector for $name<Msg, S>","highlight_start":1,"highlight_end":50},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput + FnSelector,","highlight_start":1,"highlight_end":50},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            const SELECTOR: Selector = <Msg as FnSelector>::SELECTOR;","highlight_start":1,"highlight_end":70},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Copy for $name<Msg, S>","highlight_start":1,"highlight_end":44},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Clone for $name<Msg, S>","highlight_start":1,"highlight_end":45},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            fn clone(&self) -> Self {","highlight_start":1,"highlight_end":38},{"text":"                Self {","highlight_start":1,"highlight_end":23},{"text":"                    dispatchable: self.dispatchable,","highlight_start":1,"highlight_end":53},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> $name<Msg, S>","highlight_start":1,"highlight_end":35},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput + FnSelector,","highlight_start":1,"highlight_end":50},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// Returns the associated handler selector.","highlight_start":1,"highlight_end":57},{"text":"            pub const fn selector() -> Selector {","highlight_start":1,"highlight_end":50},{"text":"                <Msg as FnSelector>::SELECTOR","highlight_start":1,"highlight_end":46},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> $name<Msg, S>","highlight_start":1,"highlight_end":35},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: FnInput + FnOutput,","highlight_start":1,"highlight_end":37},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            /// Constructs a message handler from its raw counterpart.","highlight_start":1,"highlight_end":71},{"text":"            pub const fn new(dispatchable: $dispatchable_fn<Msg, S>) -> Self {","highlight_start":1,"highlight_end":79},{"text":"                Self { dispatchable }","highlight_start":1,"highlight_end":38},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            /// Calls the dispatchable function and returns its result.","highlight_start":1,"highlight_end":72},{"text":"            pub fn eval(","highlight_start":1,"highlight_end":25},{"text":"                &self,","highlight_start":1,"highlight_end":23},{"text":"                storage: & $($tt)* S,","highlight_start":1,"highlight_end":38},{"text":"                inputs: <Msg as FnInput>::Input,","highlight_start":1,"highlight_end":49},{"text":"            ) -> <Msg as FnOutput>::Output {","highlight_start":1,"highlight_end":45},{"text":"                (self.dispatchable)(storage, inputs)","highlight_start":1,"highlight_end":53},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        impl<Msg, S> Dispatch<S> for $name<Msg, S>","highlight_start":1,"highlight_end":51},{"text":"        where","highlight_start":1,"highlight_end":14},{"text":"            Msg: Message,","highlight_start":1,"highlight_end":26},{"text":"            <Msg as FnInput>::Input: scale::Decode,","highlight_start":1,"highlight_end":52},{"text":"            <Msg as FnOutput>::Output: scale::Encode,","highlight_start":1,"highlight_end":54},{"text":"            S: Flush,","highlight_start":1,"highlight_end":22},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            fn dispatch<T>(&self, storage: &mut S, data: &CallData) -> Result<()>","highlight_start":1,"highlight_end":82},{"text":"            where","highlight_start":1,"highlight_end":18},{"text":"                T: EnvTypes,","highlight_start":1,"highlight_end":29},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                use scale::Decode as _;","highlight_start":1,"highlight_end":40},{"text":"                let args = <Msg as FnInput>::Input::decode(&mut &data.params()[..])","highlight_start":1,"highlight_end":84},{"text":"                    .map_err(|_| DispatchError::InvalidParameters)?;","highlight_start":1,"highlight_end":69},{"text":"                let result = self.eval(storage, args);","highlight_start":1,"highlight_end":55},{"text":"                if TypeId::of::<<Msg as FnOutput>::Output>() != TypeId::of::<()>() {","highlight_start":1,"highlight_end":85},{"text":"                    ink_core::env::output::<<Msg as FnOutput>::Output>(&result)","highlight_start":1,"highlight_end":80},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                if <Msg as Message>::IS_MUT {","highlight_start":1,"highlight_end":46},{"text":"                    // Flush the storage since the message might have mutated it.","highlight_start":1,"highlight_end":82},{"text":"                    Flush::flush(storage);","highlight_start":1,"highlight_end":43},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"                Ok(())","highlight_start":1,"highlight_end":23},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"    ( // Forwarding rule for `mut`","highlight_start":1,"highlight_end":35},{"text":"        $( #[$meta:meta] )*","highlight_start":1,"highlight_end":28},{"text":"        struct $name:ident( mut $dispatchable_fn:ident );","highlight_start":1,"highlight_end":58},{"text":"    ) => {","highlight_start":1,"highlight_end":11},{"text":"        impl_dispatcher_for! {","highlight_start":1,"highlight_end":31},{"text":"            $( #[$meta] )*","highlight_start":1,"highlight_end":27},{"text":"            struct $name( $dispatchable_fn ); mut","highlight_start":1,"highlight_end":50},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    };","highlight_start":1,"highlight_end":7},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"add `#![feature(const_mut_refs)]` to the crate attributes to enable","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0658]\u001b[0m\u001b[0m\u001b[1m: mutable references are not allowed in constant functions\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0m/Users/aclapinpepin/code/ink/lang/src/dispatcher.rs:186:30\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m186\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m            pub const fn new(dispatchable: $dispatchable_fn<Msg, S>) -> Self {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m242\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mimpl_dispatcher_for! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m243\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    /// Dispatcher for potentially storage mutating messages and constructors.\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m244\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    struct DispatcherMut(mut DispatchableFnMut);\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m245\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12min this macro invocation\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: add `#![feature(const_mut_refs)]` to the crate attributes to enable\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to 3 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 3 previous errors\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0658`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about this error, try `rustc --explain E0658`.\u001b[0m\n"}
